# Ictiobus

Lexer/parser/translator generator in pure Go. Generates compiler frontends
written in and accessible via Go, exclusively.

Ictiobus is intended to be implementations of the techniques given in the
textbook "Compilers: Principles, Techniques, and Tools", by Aho, Lam, Sethi, and
Ullman (otherwise known as the "Purple Dragon Book"). It is first and foremost
an experimental learning system and secondarily the parser generator used as the
parser for a scripting language in the tunaquest text adventure engine.

## Using Ictiobus

Ictiobus is used to develop parsers and other tools for languages. This allows
new languages to be created and programs written in Go to easily generate a
parser for that language, enabling the creation of new scripting languages. In
theory its output could be plugged into a modern compiler middle end or back
end, but this is not the intent and its really mostly for designing your own
quick scripting languages.

### Overview: Creating Scripting Languages

Building and using a scripting language with Ictiobus consists of a few steps.
First, you'll need to create a specification for the language. This includes a
context-free grammar that describes the language, the regular expression
patterns that are to be lexed as tokens, and any steps needed to translate
parsed constructs from your program into something your code can analyze, such
as an abstract syntax tree. This specification is then laid out in a markdown
file in the FISHI specification language, which is explained in the
[FISHI manual](docs/fishi-usage.md) and in the [FISHI spec](docs/fishi.md)
itself.

This file is then read by the `ictcc` command, which compiles a compiler
frontend for the language it describes. It outputs Go code with the token
definitions, generated lexer, generated parser, and generated syntax-directed
translation scheme built from the spec. The package it outputs will include a
`Frontend()` function which can be called by outside code to get a Frontend;
from there, `Analyze(io.Reader)` can be called on readers containg the scripting
language to parse them into the intermediate representation.

For more information on using `ictcc`, invoke it with `-h` to see the help,
check the Go docs page for the ictcc command, or see the
[ictcc manual](docs/ictcc.md).

### Installation
Ictiobus parsers are generated by running the `ictcc` command on markdown files
that contain specially-formatted codeblocks that give a specification for a
programming language. For information on that format, called FISHI, see the
[FISHI manual](docs/fishi-usage.md).

To install `ictcc` on your system, either grab one of the distributions from
the [Releases page](https://github.com/dekarrin/ictiobus/releases/) of the
Ictiobus repository, or run Go install:

```bash
go install github.com/dekarrin/ictiobus/cmd/ictcc@latest
```

### Building The Spec
Once `ictcc` is installed on your system, it's time to put together a FISHI spec
that describes the language you want to create. This section gives a brief
overview on the topic; for an in-depth description of the FISHI language and
using it to define specs, see the [FISHI manual](docs/fishi-usage.md).

A FISHI spec is defined in a markdown file with codeblocks containing FISHI
marked with the label "fishi". These are the only parts of the document that
will be read by the parser generator tool, `ictcc`. Within these blocks, you'll
need at least one each of the three parts of a FISHI spec:

* A `%%tokens` block, which gives definitions of the tokens in your language and
defines the text patterns that the lexer should use to find them in source text.
* A `%%grammar` block, which defines the context-free grammar that the parser
will use to generate a parse tree from input tokens.
* An `%%actions` block, which gives the actions for a syntax-directed
translation to take to convert a parse tree into a final value that you will
receive when calling `Analyze(io.Reader)` on input written in the new language.

Your spec might look like the following example:

    # NeatLang Specification

    This is a cool new language made with ictiobus! It's called NeatLang and it
    does simple math.

    ```fishi
    %%tokens
    
    \+                        %token +         %human plus sign '+'
    \*                        %token *         %human multiplication sign '*'
    \(                        %token lp        %human left parenthesis '('
    \)                        %token rp        %human right parenthesis ')'
    \d+                       %token int       %human integer
    [A-Za-z_][A-Za-z_0-9]*    %token id        %human identifier
    
    # ignore whitespace
    \s+                       %discard
    
    
    %%grammar
    
    {SUM}       =   {SUM} + {PRODUCT}  | {PRODUCT}
    {PRODUCT}   =   {PRODUCT} * {TERM} | {TERM}
    {TERM}      =   lp {S} rp | id | int
    
    
    %%actions
    
    %symbol {S}
    -> {S} + {E} : {^}.value = add({0}.value, {2}.value)
    -> {E}       : {^}.value = identity({0}.value)
    
    %symbol {E}
    -> {E} * {F} : {^}.value = mult({0}.value, {2}.value)
    -> {F}       : {^}.value = identity({0}.value)
    
    %symbol {F}
    -> lp {S} rp : {^}.value = identity({1}.value)
    -> id        : {^}.value = lookup_value({0}.$text)
    -> int       : {^}.value = int({0}.$text)
    ```

For the most part, FISHI is self-contained and builds up definitions used in one
section from FISHI code in a prior section; `%%tokens` sections define token
classes to be used as terminal symbols in a grammar, `%%grammar` sections define
non-terminal symbols by using the defined terminal symbols, and `%%actions`
sections will refer to both non-terminal and terminal symbols defined in the
prior section.

However, the `%%actions` section needs a bit more extra tooling before it can
be used. It refers to *hook functions* by names in its syntax-directed
definitions: `add`, `identity`, `mult`, `lookup_value`, and `int`. These
functions must be implemented in Go code and provided to ictiobus by creating a
`github.com/dekarrin/ictiobus/trans.HookMap` called `HookTable` that maps the
names used in the FISHI spec to their implementation functions. Later, when
`ictcc` is called, it will be informed of this code's location using CLI
arguments.

The hook functions for the above langauge might look something like this:

```go
package neatlanghooks

var (
	HooksTable = trans.HookMap{
		"int":          hookInt,
		"identity":     hookIdentity,
		"add":          hookAdd,
		"mult":         hookMult,
		"lookup_value": hookLookupValue,
	}
)

func hookInt(_ trans.SetterInfo, args []interface{}) (interface{}, error)
```

### Running `ictcc`
Ictiobus is invoked by running the `ictcc` command on markdown files. The files
will be scanned for code fences with a langauge tag of `fishi`. FISHI is the
Frontend Instruction Specification for self-Hosting Ictiobus and is the primary
way that languages are specified to build compilers for.

These files are read in and then a compiler is produced.

```shell
./ictcc test/test.md
```

## Development
The scripts directory contains several shell scripts useful for development.

### Building
To build the `ictcc` command, execute the `build.sh` script from bash or
compatible shell.

```shell
scripts/build.sh
```
