# Ictiobus
Lexer/parser/translator generator in pure Go. Generates compiler frontends
written in and accessible via Go, exclusively.

Ictiobus is intended to be implementations of the techniques given in the
textbook "Compilers: Principles, Techniques, and Tools", by Aho, Lam, Sethi, and
Ullman (otherwise known as the "Purple Dragon Book"). It is first and foremost
an experimental learning system and secondarily the parser generator used as the
parser for a scripting language in the tunaquest text adventure engine.


## Creating Scripting Languages
Ictiobus is used to develop parsers and other tools for languages. This allows
new languages to be created and programs written in Go to easily generate a
parser for that language, enabling the creation of new scripting languages. In
theory its output could be plugged into a modern compiler middle end or back
end, but this is not the intent and its really mostly for designing your own
quick scripting languages.

Building and using a scripting language with Ictiobus consists of a few steps.
First, you'll need to create a specification for the language. This includes a
context-free grammar that describes the language, the regular expression
patterns that are to be lexed as tokens, and any steps needed to translate
parsed constructs from your program into something your code can analyze, such
as an abstract syntax tree. This specification is then laid out in a markdown
file in the FISHI specification language, which is explained in the
[FISHI manual](./fishi-usage.md) and in the [FISHI spec](./fishi.md) itself.

This file is then read by the `ictcc` command, which compiles a compiler
frontend for the language it describes. It outputs Go code with the token
definitions, generated lexer, generated parser, and generated syntax-directed
translation scheme built from the spec. The package it outputs will include a
`Frontend()` function which can be called by outside code to get a Frontend;
from there, `Analyze(io.Reader)` can be called on readers containg the scripting
language to parse them into the intermediate representation.

## Installation
Ictiobus parsers are generated by running the `ictcc` command on markdown files
that contain specially-formatted codeblocks that give a specification for a
programming language. For information on that format, called FISHI, see the
[FISHI manual](./fishi-usage.md).

To install `ictcc` on your system, either grab one of the distributions from
the [Releases page](https://github.com/dekarrin/ictiobus/releases/) of the
Ictiobus repository, or run Go install:

```bash
go install github.com/dekarrin/ictiobus/cmd/ictcc@latest
```

## Running
Ictiobus is invoked by running the `ictcc` command on markdown files. The files
will be scanned for code fences with a langauge tag of `fishi`. FISHI is the
Frontend Instruction Specification for self-Hosting Ictiobus and is the primary
way that languages are specified to build compilers for.

These files are read in and then a compiler is produced. At least in theory. For
now, it only prints an AST out.

```shell
./ictcc test/test.md
```

## Development
The scripts directory contains several shell scripts useful for development.

### Building
To build the `ictcc` command, execute the `build.sh` script from bash or
compatible shell.

```shell
scripts/build.sh
```

### Running

Ictiobus is invoked by running the `ictcc` command on markdown files. The files
will be scanned for code fences with a langauge tag of `fishi`. FISHI is the
Frontend Instruction Specification for self-Hosting Ictiobus and is the primary
way that languages are specified to build compilers for.

These files are read in and then a compiler is produced. At least in theory. For
now, it only prints an AST out.

```shell
./ictcc test/test.md
```
