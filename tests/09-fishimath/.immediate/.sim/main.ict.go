/*
Testfishimath runs a compiler frontend generated by ictiobus on one or
more files and outputs the parsed intermediate representation type
([]fmhooks.FMValue) as a string to stdout.

Usage:

	testfishimath [flags] file1.md file2.md ...
	testfishimath [flags] -
	testfishimath [flags] --sim
	testfishimath [flags] -C code

If '-' is specified for one of the files, testfishimath will read from stdin
for that file. If there are multiple '-' given, only the first one actually
results in reading from stdin.
*/
package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"

	"github.com/dekarrin/ictiobus/langexec/fishimath/internal/fmhooks"
	"github.com/dekarrin/ictiobus/langexec/fishimath/internal/simfishimath"

	"github.com/dekarrin/ictiobus/fishi"
	se "github.com/dekarrin/ictiobus/syntaxerr"
	"github.com/dekarrin/ictiobus/trans"

	"github.com/spf13/pflag"
)

const (
	ExitSuccess = iota
	ExitErrNoFiles
	ExitErrSyntax
	ExitErrInvalidFlags
	ExitErrFatalWarn
	ExitErr
)

const (
	versionString = "testfishimath 1.0 (for FISHIMath)"
)

var (
	returnCode = ExitSuccess
)

// flags
var (
	flagWarnFatal    = pflag.StringArrayP("fatal", "F", nil, "Treat given warning as a fatal error")
	flagWarnSuppress = pflag.StringArrayP("suppress", "S", nil, "Suppress output of given warning")

	flagCommand     = pflag.StringP("command", "C", "", "Code to execute before any source code files are read")
	flagQuietMode   = pflag.BoolP("quiet", "q", false, "Quiet mode; disables output of the IR")
	flagLexerTrace  = pflag.BoolP("debug-lexer", "l", false, "Print the lexer trace to stdout")
	flagParserTrace = pflag.BoolP("debug-parser", "p", false, "Print the parser trace to stdout")
	flagPrintTrees  = pflag.BoolP("tree", "t", false, "Print the parse trees of each file read to stdout")
	flagVersion     = pflag.Bool("version", false, "Print the version of testfishimath and exit")
	flagSim         = pflag.Bool("sim", false, "Run analysis on a series of simulated parse trees intended to cover all rules and then exit")
	flagSimTrees    = pflag.Bool("sim-trees", false, "Show full simulated parse trees that caused SDTS validation errors")
	flagSimGraphs   = pflag.Bool("sim-graphs", false, "Show dependency graph for each simulated tree that caused SDTS validation errors")
	flagSimFirstErr = pflag.Bool("sim-first-err", false, "Show only the first error found in SDTS validation of simulated trees")
	flagSimSkipErrs = pflag.Int("sim-skip-errs", 0, "Skip the first N errors found in SDTS validation of simulated trees")
)

func main() {
	// preserve possibly-set exit code while also checking for panic and
	// propagating it if there was one.
	defer func() {
		if panicErr := recover(); panicErr != nil {
			// we are panicking, make sure we dont lose the panic just because
			// we checked
			panic("unrecoverable panic occured")
		} else {
			os.Exit(returnCode)
		}
	}()

	pflag.Parse()

	if *flagVersion {
		fmt.Println(versionString)
		return
	}

	warnHandler, err := fishi.NewWarnHandlerFromCLI(*flagWarnSuppress, *flagWarnFatal)
	if err != nil {
		fmt.Fprintf(os.Stderr, "ERR: %s\n", err)
		returnCode = ExitErrInvalidFlags
		return
	}

	opts := simfishimath.FrontendOptions{
		LexerTrace:  *flagLexerTrace,
		ParserTrace: *flagParserTrace,
	}

	hooksMapping := fmhooks.HooksTable
	langFront := simfishimath.Frontend(hooksMapping, &opts)

	if *flagSim {
		hooksMapping := fmhooks.HooksTable

		langFront := simfishimath.Frontend(hooksMapping, nil)

		// hooks will be set, so run validation now
		valProd := langFront.Lexer.FakeLexemeProducer(true, "")

		di := trans.ValidationOptions{
			ParseTrees:    *flagSimTrees,
			FullDepGraphs: *flagSimGraphs,
			ShowAllErrors: !*flagSimFirstErr,
			SkipErrors:    *flagSimSkipErrs,
		}

		sdtsWarns, sdtsErr := trans.Validate(langFront.SDTS, langFront.Parser.Grammar(), langFront.IRAttribute, di, valProd)
		var warns []fishi.Warning
		for _, w := range sdtsWarns {
			warns = append(warns, fishi.Warning{Type: fishi.WarnValidation, Message: w})
		}

		var fatalValWarn error
		for _, w := range warns {
			if wErr := warnHandler.Handlef("%s\n\n", w); wErr != nil {
				fatalValWarn = wErr
			}
		}

		if sdtsErr != nil {
			fmt.Fprintf(os.Stderr, "ERR: %v\n", sdtsErr.Error())
			returnCode = ExitErr
			return
		} else if fatalValWarn != nil {
			fmt.Fprintf(os.Stderr, "ERR: %v\n", fatalValWarn.Error())
			returnCode = ExitErrFatalWarn
			return
		}

		if !*flagQuietMode {
			fmt.Printf("Simulation completed with no errors\n")
		}
		return
	}

	var cmdExecuted bool
	if *flagCommand != "" {
		var cmdReader io.Reader
		cmdBuf := bytes.NewBuffer([]byte(*flagCommand))

		cmdReader = cmdBuf

		cmdIR, cmdPT, cmdErr := langFront.Analyze(cmdReader)

		// parse tree might be valid no matter what, so we print it first
		if *flagPrintTrees {
			fmt.Println(cmdPT.String())
		}

		if cmdErr != nil {
			if syntaxErr, ok := cmdErr.(*se.Error); ok {
				fmt.Fprintf(os.Stderr, "%s\n", syntaxErr.MessageForFile("<COMMAND>"))
				returnCode = ExitErrSyntax
			} else {
				fmt.Fprintf(os.Stderr, "ERR: %s: %s\n", "<COMMAND>", cmdErr)
				returnCode = ExitErr
			}
			return
		}

		if !*flagQuietMode {

			fmt.Printf("%s\n", cmdIR)

		}

		cmdExecuted = true
	}

	files := pflag.Args()
	if len(files) == 0 {
		if !cmdExecuted {
			// don't exit with error if user specified -c
			fmt.Fprintf(os.Stderr, "No files specified\n")
			returnCode = ExitErrNoFiles
		}
		return
	}

	// track open files so we can close them
	openFiles := make([]*os.File, 0, len(files))
	defer func() {
		for _, f := range openFiles {
			f.Close()
		}
	}()

	var haveReadStdin bool
	var r io.Reader
	for _, f := range files {
		if f == "-" {
			if haveReadStdin {
				continue
			} else {
				haveReadStdin = true
			}
		}

		if f == "-" {
			// read from stdin
			r = os.Stdin

		} else {
			file, err := os.Open(f)
			if err != nil {
				fmt.Fprintf(os.Stderr, "ERR: %s: %s\n", f, err)
				returnCode = ExitErr
				return
			}
			openFiles = append(openFiles, file)

			r = bufio.NewReader(file)
		}

		ir, pt, err := langFront.Analyze(r)

		// parse tree might be valid no matter what, so we print it first
		if *flagPrintTrees {
			fmt.Println(pt.String())
		}

		if err != nil {
			if syntaxErr, ok := err.(*se.Error); ok {
				errFilename := f
				if f == "-" {
					errFilename = "<STDIN>"
				}
				fmt.Fprintf(os.Stderr, "%s\n", syntaxErr.MessageForFile(errFilename))
				returnCode = ExitErrSyntax
			} else {
				fmt.Fprintf(os.Stderr, "ERR: %s: %s\n", f, err)
				returnCode = ExitErr
			}
			return
		}

		if !*flagQuietMode {
			if f != "-" {
				fmt.Printf("=== Analysis of %s ===\n", filepath.Base(f))
			}

			fmt.Printf("%s\n", ir)

		}
	}
}
