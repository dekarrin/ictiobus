{{/* irmain.go.tmpl is the main entry point for generated code that has the
ability to debug the lexer, parser, and output the printed IR once complete. */}}
{{/* own binary. */ -}}

/*
{{ .BinName | title }} runs a compiler frontend generated by ictiobus on one or
more files and outputs the parsed intermediate representation (A
{{ .IRTypePackage }}.{{ .IRType }}) as a string to stdout.

Usage:

	{{ .BinName }} [flags] file1.md file2.md ...
*/
package main

import (
	"fmt"
	"bufio"
    "os"
	"path/filepath"

	"{{ .BinPkg }}/internal/{{ .HooksPkg }}"
	"{{ .BinPkg }}/internal/{{ .FrontendPkg }}"
{{if .IRTypePackage -}}
	"{{ .IRTypePackage }}"
{{- end}}

	"github.com/dekarrin/ictiobus/trans"

	"github.com/spf13/pflag"
)

const (
    ExitSuccess = iota
	ExitErrNoFiles
	ExitErrSyntax
    ExitErr
)

const (
	versionString = "{{ .BinName }} {{ .BinVersion }}"
)

var (
    returnCode = ExitSuccess
)

// flags
var (
	quietMode         *bool = pflag.BoolP("quiet", "q", false, "Quiet mode; disables output of the IR")
	lexerTrace        *bool = pflag.BoolP("debug-lexer", "l", false, "Print the lexer trace to stdout")
	parserTrace       *bool = pflag.BoolP("debug-parser", "p", false, "Print the parser trace to stdout") 
	printTrees        *bool = pflag.Bool("t", false, "Print the parse trees of each file read to stdout")
	version			  *bool = pflag.Bool("version", false, "Print the version of {{ .BinName }} and exit")
	doSimulation      *bool = pflag.Bool("sim", false, "Run analysis on a series of simulated parse trees intended to cover all rules and then exit")
	simSDTSShowTrees  *bool = pflag.Bool("sim-trees", false, "Show full simulated parse trees that caused SDTS validation errors")
	simSDTSShowGraphs *bool = pflag.Bool("sim-graphs", false, "Show dependency graph for each simulated tree that caused SDTS validation errors")
	simSDTSFirstOnly  *bool = pflag.Bool("sim-first-errs", false, "Show only the first error found in SDTS validation of simulated trees")
	simSDTSSkip       *int  = pflag.Int("sim-skip-errs", 0, "Skip the first N errors found in SDTS validation of simulated trees")
)

func main() {
	// preserve possibly-set exit code while also checking for panic and
    // propagating it if there was one.
	defer func() {
		if panicErr := recover(); panicErr != nil {
			// we are panicking, make sure we dont lose the panic just because
			// we checked
			panic("unrecoverable panic occured")
		} else {
			os.Exit(returnCode)
		}
	}()

	pflag.Parse()

	if *version {
		fmt.Println(versionString)
		return
	}

	opts := {{ .FrontendPkg }}.FrontendOptions{
		LexerTrace: *lexerTrace,
		ParserTrace: *parserTrace,
	}

	hooksMapping := {{ .HooksPkg }}.{{ .HooksTableExpr }}
	langFront := {{ .FrontendPkg }}.Frontend(hooksMapping, &opts)

	if *doSimulation {
		hooksMapping := {{ .HooksPkg }}.{{ .HooksTableExpr }}

		langFront := {{ .FrontendPkg }}.Frontend(hooksMapping, nil)

		// hooks will be set, so run validation now
		valProd := langFront.Lexer.FakeLexemeProducer(true, "")

		di := trans.ValidationOptions{
			ParseTrees:    *simSDTSShowTrees,
			FullDepGraphs: *simSDTSShowGraphs,
			ShowAllErrors: !*simSDTSFirstOnly,
			SkipErrors:    *simSDTSSkip,
		}

		sddErr := langFront.SDT.Validate(langFront.Parser.Grammar(), langFront.IRAttribute, di, valProd)
		if sddErr != nil {
			fmt.Fprintf(os.Stderr, "validation error: %v\n", sddErr.Error())
			returnCode = ExitErr
			return
		}

		if !*quietMode {
			fmt.Printf("Simulation completed with no errors\n")
		}
		return
	}

	files := pflag.Args()
	if len(files) == 0 {
		fmt.Fprintf(os.Stderr, "No files specified\n")
		returnCode = ExitErrNoFiles
		return
	}
	
	for _, f := range files {
		file, err := os.Open(f)
		if err != nil {
			fmt.Fprintf(os.Stderr, "ERR: %s: %s\n", f, err)
			returnCode = ExitErr
			return
		}

		r := bufio.NewReader(file)

		ir, pt, err := langFront.Analyze(r)

		// parse tree might be valid no matter what, so we print it first
		if *printTrees {
			fmt.Println(pt.String())
		}

		if err != nil {
			fmt.Fprintf(os.Stderr, "ERR: %s: %s\n", f, err)
			returnCode = ExitErrSyntax
			return
		}

		if !*quietMode {
			fmt.Println("=== Analysis of %s ===\n%s\n\n", filepath.Base(f), ir)
		}
	}
}