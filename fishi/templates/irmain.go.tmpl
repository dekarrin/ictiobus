{{/* irmain.go.tmpl is the main entry point for generated code that has the
ability to debug the lexer, parser, and output the printed IR once complete. */}}
{{/* own binary. */ -}}

/*
{{ .BinName | title }} runs a compiler frontend generated by ictiobus on one or
more files and outputs the parsed intermediate representation (A
{{ .IRTypePackage }}.{{ .IRTypeExpr }}) as a string to stdout.

Usage:

	{{ .BinName }} [flags] file1.md file2.md ...
*/
package main

import (
	"fmt"
	"bufio"
    "os"
	"flag"

	"{{ .BinPkg }}/internal/{{ .HooksPkg }}"
	"{{ .BinPkg }}/internal/{{ .FrontendPkg }}"
	"{{ .IRTypePackage }}"
)

const (
    ExitSuccess = iota
	ExitErrNoFiles
	ExitErrSyntax
    ExitErr
)

const (
	versionString = "{{ .BinName }} {{ .BinVersion }}"
)

var (
    returnCode = ExitSuccess
)

// flags
var (
	quietMode bool
	printTrees bool = flag.Bool("t", false, "Print the parse trees of each file read to stdout")
	version *bool = flag.Bool("version", false, "Print the version of {{ .BinName }} and exit")
	lexerTrace  *bool = flag.Bool("debug-lexer", false, "Print the lexer trace to stdout")
	parserTrace *bool = flag.Bool("debug-parser", false, "Print the parser trace to stdout")
)

// init flags
func init() {
	const (
		quietUsage       = "Quiet mode"
	)
	flag.BoolVar(&quietMode, "quiet", false, quietUsage)
	flag.BoolVar(&quietMode, "q", false, quietUsage+" (shorthand)")
}

func main() {
	// preserve possibly-set exit code while also checking for panic and
    // propagating it if there was one.
	defer func() {
		if panicErr := recover(); panicErr != nil {
			// we are panicking, make sure we dont lose the panic just because
			// we checked
			panic("unrecoverable panic occured")
		} else {
			os.Exit(returnCode)
		}
	}()

	flag.Parse()

	if *version {
		fmt.Println(versionString)
		return
	}

	files := flag.Args()

	if len(files) == 0 {
		fmt.Fprintf(os.Stderr, "No files specified\n")
		returnCode = ExitErrNoFiles
		return
	}

	hooksMapping := {{ .HooksPkg }}.{{ .HooksTableExpr }}
	langFront := {{ .FrontendPkg }}.Frontend(hooksMapping, nil)
	
	for _, f := files {
		file, err := os.Open(f)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error opening file %s: %s\n", f, err)
			returnCode = ExitErr
			return
		}

		r := bufio.NewReader(file)

		ir, pt, err := langFront.Analyze(r)

		// parse tree might be valid no matter what, so we print it first
		if *printTrees {
			fmt.Println(pt.String())
		}

		res, err := fishi.ParseMarkdownFile(file, fo)
		if res.AST != nil {
			if joinedAST == nil {
				joinedAST = res.AST
			} else {
				joinedAST.Nodes = append(joinedAST.Nodes, res.AST.Nodes...)
			}
		}
	}
}