{{/* irmain.go.tmpl is the main entry point for generated code that has the
ability to debug the lexer, parser, and output the printed IR once complete. */}}
{{/* own binary. */ -}}

/*
{{ .BinName | title }} runs a compiler frontend generated by ictiobus on one or
more files and outputs the parsed intermediate representation (A
{{ .IRTypePackage }}.{{ .IRTypeExpr }}) as a string to stdout.

Usage:

	{{ .BinName }} [flags] file1.md file2.md ...
*/
package main

import (
	"fmt"
	"bufio"
    "os"
	"flag"

	"{{ .BinPkg }}/internal/{{ .HooksPkg }}"
	"{{ .BinPkg }}/internal/{{ .FrontendPkg }}"
	"{{ .IRTypePackage }}"

	"github.com/dekarrin/ictiobus/trans"
)

const (
    ExitSuccess = iota
	ExitErrNoFiles
	ExitErrSyntax
    ExitErr
)

const (
	versionString = "{{ .BinName }} {{ .BinVersion }}"
)

var (
    returnCode = ExitSuccess
)

// flags
var (
	quietMode bool
	lexerTrace  bool
	parserTrace bool
	printTrees bool         = flag.Bool("t", false, "Print the parse trees of each file read to stdout")
	version			  *bool = flag.Bool("version", false, "Print the version of {{ .BinName }} and exit")
	doSimulation      *bool = flag.Bool("sim", false, "Run analysis on a series of simulated parse trees intended to cover all rules and then exit")
	simSDTSShowTrees  *bool = flag.Bool("sim-trees", false, "Show full simulated parse trees that caused SDTS validation errors")
	simSDTSShowGraphs *bool = flag.Bool("sim-graphs", false, "Show dependency graph for each simulated tree that caused SDTS validation errors")
	simSDTSFirstOnly  *bool = flag.Bool("sim-first-errs", false, "Show only the first error found in SDTS validation of simulated trees")
	simSDTSSkip       *int  = flag.Int("sim-skip-errs", 0, "Skip the first N errors found in SDTS validation of simulated trees")
)

// init flags
func init() {
	const (
		quietUsage       = "Quiet mode; disables output of the IR"
		lexerUsage		 = "Print the lexer trace to stdout"
		parserUsage		 = "Print the parser trace to stdout"
	)
	flag.BoolVar(&quietMode, "quiet", false, quietUsage)
	flag.BoolVar(&quietMode, "q", false, quietUsage+" (shorthand)")
	flag.BoolVar(&lexerTrace, "debug-lexer", false, lexerUsage)
	flag.BoolVar(&lexerTrace, "l", false, lexerUsage+" (shorthand)")
	flag.BoolVar(&parserTrace, "debug-parser", false, parserUsage)
	flag.BoolVar(&parserTrace, "p", false, parserUsage+" (shorthand)")
}

func main() {
	// preserve possibly-set exit code while also checking for panic and
    // propagating it if there was one.
	defer func() {
		if panicErr := recover(); panicErr != nil {
			// we are panicking, make sure we dont lose the panic just because
			// we checked
			panic("unrecoverable panic occured")
		} else {
			os.Exit(returnCode)
		}
	}()

	flag.Parse()

	if *version {
		fmt.Println(versionString)
		return
	}

	files := flag.Args()

	if len(files) == 0 {
		fmt.Fprintf(os.Stderr, "No files specified\n")
		returnCode = ExitErrNoFiles
		return
	}

	opts := {{ .FrontendPkg }}.FrontendOptions{
		LexerTrace: *lexerTrace,
		ParserTrace: *parserTrace,
	}

	hooksMapping := {{ .HooksPkg }}.{{ .HooksTableExpr }}
	langFront := {{ .FrontendPkg }}.Frontend(hooksMapping, nil)

	if *doSimulation {
		hooksMapping := {{ .HooksPkg }}.{{ .HooksTableExpr }}

		langFront := {{ .FrontendPkg }}.Frontend(hooksMapping, nil)

		// hooks will be set, so run validation now
		valProd := langFront.Lexer.FakeLexemeProducer(true, "")

		di := trans.ValidationOptions{
			ParseTrees:    *simSDTSShowTrees,
			FullDepGraphs: *simSDTSShowGraphs,
			ShowAllErrors: !*simSDTSFirstOnly,
			SkipErrors:    *simSDTSSkip,
		}

		sddErr := langFront.SDT.Validate(langFront.Parser.Grammar(), langFront.IRAttribute, di, valProd)
		if sddErr != nil {
			fmt.Fprintf(os.Stderr, "validation error: %v\n", sddErr.Error())
			returnCode = ExitErr
			return
		}

		if !quietMode {
			fmt.Printf("simulation completed with no errors\n")
		}
		return
	}
	
	for _, f := files {
		file, err := os.Open(f)
		if err != nil {
			fmt.Fprintf(os.Stderr, "ERR: %s: %s\n", f, err)
			returnCode = ExitErr
			return
		}

		r := bufio.NewReader(file)

		ir, pt, err := langFront.Analyze(r)

		// parse tree might be valid no matter what, so we print it first
		if *printTrees {
			fmt.Println(pt.String())
		}

		if err != nil {
			fmt.Fprintf(os.Stderr, "ERR: %s: %s\n", f, err)
			returnCode = ExitErrSyntax
			return
		}

		if !quietMode {
			fmt.Println("----- %s -----\n%v\n\n"ir.String())
		}
	}
}