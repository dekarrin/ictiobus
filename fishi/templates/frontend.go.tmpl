package {{ .FrontendPackage }}

/*
File automatically generated by the ictiobus compiler. DO NOT EDIT. This was
created by invoking ictiobus with the following command:

    {{ .Command }} {{ .CommandArgs }}
*/

import (
	"fmt"
    "os"

	"github.com/dekarrin/ictiobus"
	"github.com/dekarrin/ictiobus/trans"
	"github.com/dekarrin/ictiobus/types"
)

// FrontendOptions allows options to be set on the frontend returned by
// Frontend. It allows setting of debug flags and other optional functionality.
type FrontendOptions struct {

    // LexerEager is whether the Lexer should immediately read all input the
    // first time it is called. The default is lazy lexing, where the minimum
    // number of tokens are read when required by the parser.
    LexerEager  bool

    // LexerTrace is whether to add tracing functionality to the lexer. This
    // will cause the tokens to be printed to stderr as they are lexed. Note
    // that with LexerEager set, this implies that they will all be lexed and
    // therefore printed before any parsing occurs.
	LexerTrace  bool

    // ParserTrace is whether to add tracing functionality to the parser. This
    // will cause parsing events to be printed to stderr as they occur. This
    // includes operations such as token or symbol stack manipulation, and for
    // LR parsers, shifts and reduces.
	ParserTrace bool
}

// Frontend returns the complete compiled frontend for the {{ .Lang }} langauge.
// The hooks map must be provided as it is the interface between the translation
// scheme in the frontend and the external code executed in the backend. The
// opts parameter allows options to be set on the frontend for debugging and
// other purposes. If opts is nil, it is treated as an empty FrontendOptions.
func Frontend[IRType any](hooks map[string]trans.AttributeSetter, opts *FrontendOptions) ictiobus.Frontend[IRType] {
    var feOpts FrontendOptions
    
    if opts != nil {
        feOpts = *opts
    }

    fe := ictiobus.Frontend[IRType]{
        Language: "{{ .Lang }}",
        Version: "{{ .Version }}",
        IRAttribute: "{{ .IRAttribute }}",
        Lexer: Lexer(!feOpts.LexerEager),
        Parser: Parser(),
        Translator: Translator(),
    }
    
    // Add traces if requested

    if feOpts.LexerTrace {
        fe.Lexer.RegisterTokenListener(func(t types.Token) {
			fmt.Fprintf(os.Stderr, "Token: %s\n", t)
		})
    }

	if opts.ParserTrace {
		fe.Parser.RegisterTraceListener(func(s string) {
			fmt.Fprintf(os.Stderr, "Parser: %s\n", s)
		})
	}

    // Set the hooks
    fe.SDT.SetHooks(hooks)

    return fe
}